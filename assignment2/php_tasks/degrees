#!/usr/bin/php
<?php

////////////////////////////////////////////////////////////////////////////////
//                                TASK F                                      //
////////////////////////////////////////////////////////////////////////////////
//
// The toprank script takes in 3 or 4 commandline arguments:
// ./toprank K StartYear EndYear
// Or:
// ./toprank Genres K StartYear EndYear
// Where Genres is a list of genres separated by '&', K is the top K movies
// Ranked by IMDB score and then by the number of votes
// (both in descending order) between (and including) StartYear and EndYear,
// With 1 <= K <= 1000, 1900 < StartYear <= EndYear < 2020 and your program
// Will not be tested with a list of more than 8 genres. We interpret '&' as
// conjunction, i.e., the selected movies shall contain all the specified
// Genres. When Genres is not provided (when your program takes in 3 arguments),
// Perform the same ranking but on movies with any genres. Do not include any
// Movie titles with empty year.
//

// include the common PHP code file
require("a2.php");

// PROGRAM BODY BEGINS

$usage = "Usage: $argv[0] Actor lower_bound upper_bound";
$db = dbConnect(DB_CONNECTION);

// Check arguments
if (count($argv) != 4){ 
  exit("$usage\n");
}

$start = $argv[1];
$lower_bound = $argv[2];
$upper_bound = $argv[3];
if($lower_bound > $upper_bound){
	exit("1 =< lower_bound <= upper_bound <= 6");
}
if($lower_bound < 1 || $lower_bound > 6 || $upper_bound < 1 || $upper_bound > 6){
	exit("1 =< lower_bound <= upper_bound <= 6");
}
$q = "SELECT id from actor where name ILIKE '$start' LIMIT 1;";
$r = dbQuery($db, mkSQL($q, $start));
$t = dbNext($r);

if(empty($t[0])){
	exit("$start is not an actor\n");
}

$start = $t[0];
$q = "SELECT actor1_node, actor2_node from graph;";
$r = dbQuery($db, mkSQL($q));
$graph = array();
while (($t = dbNext($r))) {
  $graph[$t[0]][$t[1]] = true;
  $graph[$t[1]][$t[0]] = true;
}
$to_visit = array();
$seen_actor = array();
$seen_path = array();
$all_bounded_actors = array();
for($i = $lower_bound; $i <= $upper_bound; $i++){
	$all_bounded_actors[$i] = array();
}

$ida = 1;
while($ida <= $upper_bound){
	$current = array($start);
	array_push($to_visit, $current);
	$seen_actor[$start] = 1;
	$seen_path = array($current);
	while(sizeof($to_visit) > 0){
		$current = array_pop($to_visit);
		//array_push($seen_path, $current);
		$inspection_node = end($current);
		if(sizeof($current) - 1 <= $upper_bound && sizeof($current) - 1 >= $lower_bound){
			
			array_push($all_bounded_actors[sizeof($current) - 1], actor_from_id($inspection_node));
		}
		if(sizeof($current) <= $ida){
			foreach($graph[$inspection_node] as $node => $val){
				if(!in_array($node, $current)){
					if(!array_key_exists($node, $seen_actor)){
						$seen_actor[$node] = 7;
					}
					if(!array_key_exists($node, $seen_path)){
						$seen_path[$node] = -1;
					}
					if(!($seen_path[$node] == -1)){
						//echo $seen_path[$node]."poo\n";
						continue;
					}else{
						//echo $seen_actor[$node]."<===>".sizeof($current)."\n";
						if(sizeof($current) <= $seen_actor[$node]){
							$seen_path[$node] = 1;
							$seen_actor[$node] = sizeof($current);
							$new_path = $current;
							array_push($new_path, $node);
							array_push($to_visit, $new_path);
						}
					}
				}
			} 
		}
	}
	$seen_path = array();
	$to_visit = array();
	$ida++;
}
//print_r($all_bounded_actors);

$visited = array();
$i = 1;
foreach($all_bounded_actors as $node => $val){
	$val = array_unique($val);
	natcasesort($val);
	//print_r($val);
	foreach($val as $actor){
		//if((!in_array($actor, $visited))){
			$count = $node;
			echo $i.". $actor ($count)\n";
			$i++;
			//array_push($visited, $actor);
		//}
	}
	
}
//print_r($all_bounded_actors);


?>