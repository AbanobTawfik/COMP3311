#!/usr/bin/php
<?php

////////////////////////////////////////////////////////////////////////////////
//                                TASK E                                      //
////////////////////////////////////////////////////////////////////////////////
//
// The toprank script takes in 3 or 4 commandline arguments:
// ./toprank K StartYear EndYear
// Or:
// ./toprank Genres K StartYear EndYear
// Where Genres is a list of genres separated by '&', K is the top K movies
// Ranked by IMDB score and then by the number of votes
// (both in descending order) between (and including) StartYear and EndYear,
// With 1 <= K <= 1000, 1900 < StartYear <= EndYear < 2020 and your program
// Will not be tested with a list of more than 8 genres. We interpret '&' as
// conjunction, i.e., the selected movies shall contain all the specified
// Genres. When Genres is not provided (when your program takes in 3 arguments),
// Perform the same ranking but on movies with any genres. Do not include any
// Movie titles with empty year.
//

// include the common PHP code file
require("a2.php");

// PROGRAM BODY BEGINS

$usage = "Usage: $argv[0] Start Goal";
$db = dbConnect(DB_CONNECTION);

// Check arguments
if (count($argv) != 3){ 
  exit("$usage\n");
}

$q = " SELECT * from pathfinding_actors;";
$r = dbQuery($db, mkSQL($q));
// Iterate through the results and create graph which will be used for path finding
$graph = array();
while (($t = dbNext($r))) {
  if(empty($graph[strtolower($t[1])])){
  	$graph[strtolower($t[1])] = array();
  }
  if(empty($graph[strtolower($t[5])])){
  	$graph[strtolower($t[5])] = array();  
  }
  if(empty($t[4])){
  	$graph[strtolower($t[1])][strtolower($t[5])] = $t[3];
  }else{
  	$graph[strtolower($t[1])][strtolower($t[5])] = $t[3].'-&-'.$t[4];
  }
}
$visited = array();
$to_visit = new SplQueue();
$start = strtolower($argv[1]);
$goal = strtolower($argv[2]);
$current = $start;

array_push($visited, $start);
$to_visit->enqueue(array($start));
$shortest_path_length = -1;
$found_shortest_paths = false;
$all_shortest_paths = array();


while(!($to_visit->isEmpty())){
	$current = $to_visit->dequeue();
	if((sizeof($current) > $shortest_path_length - 1 && $shortest_path_length != -1) && sizeof($current) > 6){
		break;
	}
	$inspection_node = end($current);
	foreach($graph[$inspection_node] as $node => $val){
		if(!in_array($node, $current)){
			$new_array = $current;
			array_push($new_array, $node);
			$to_visit->enqueue($new_array);

		}
		if(strtolower($node) == $goal && !$found_shortest_paths){
			$found_shortest_paths = true;
			array_push($all_shortest_paths, $new_array);
			$found_shortest_paths = true;
			$shortest_path_length = sizeof($new_array);
			print_r($new_array);
		}
		if(strtolower($node) == $goal){
			array_push($all_shortest_paths, $new_array);
			$found_shortest_paths = true;
			print_r($new_array);
		}
	}
}
//print_r($all_shortest_paths);
?>